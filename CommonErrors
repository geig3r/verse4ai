Please review the errors below to avoid them when creating code for Verse devices in UEFN. The following errors are common to see in Verse scripts generated by LLMs.
Verse is unforgiving and ultra strict. Do not attempt to use common optimization tricks because you will fail every time. 
if (x = 0.0): return # this fails.  return Type = MyEnum.Red or Type = MyEnum.Blue # this fails. Do not optimize unless asked to do so.  
The only comment character you should be using for verse is #
Failable expressions in Verse must be used inside failure contexts, like if, case, or for, with pattern matching 
for loop in Verse is one of the following: for (Item : Items): or for (Index => 0..20): #where the numbers can be replaced by vars like MyArray.Length-1.  
Print statements in verse can take tokenized variables. Print("Val: {VariableName}", ?Duration := 10.0, ?Color := NamedColors.Orange). Do not attempt to tokenize agents it will fail
You need a specific function wrapped in a Print like this: Print(ToMessageStrPlayer("My string here", Agent))
Variables are immutable unless you declare them initially with var VariableName : type = type{} or initial value.  Then use 'set' keyword to change the value (this will be a failable expression so use if statement)
This invocation calls a function that has the 'no_rollback' effect, which is not allowed by its context.(3512). Solution: To fix this error, you need to use the spawn keyword to create a new task when calling the Activate method which has a no_rollback effect.
Explicit return out of a failure context is not allowed.

Verse Syntax Notes:
Strongly typed to minimize opportunities for uncaught errors in development or deployment and support static checking.
Multi-paradigm to use the best of functional programming, object-oriented programming, and imperative programming, such as being as deterministic as possible. One example of this is that data is immutable by default, and given the same code and data, results will always be exactly the same.
There is no distinction between statements and expressions. In Verse, everything is an expression, which means that everything has a result.
Failure is control flow. Instead of using true / false values to change the flow of your program (such as with decision points), Verse uses failable expressions, which produce a value if they succeed or don’t if they fail. Failable expressions can only be executed in failure contexts, such as if expressions.
The ability to do speculative execution within failure contexts, meaning you can try out actions without committing them. When an expression succeeds, the effects of the expression are committed, but if the expression fails, the effects of the expression are rolled back as though the expression never happened. This way, you can execute a series of actions that accumulate changes, but those actions will be undone if a failure occurs in the failure context.
**Concurrency at the language level so you don’t need to rely on system-level threads across multiple processors to perform actions simultaneously. You can author time flow the same as you do control flow by using built-in concurrency expressions in the language.



(* Ultimate Exhaustive EBNF Grammar for Verse Programming Language *)

(* Basic Symbols *)
letter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | 
         "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
underscore = "_" ;

(* Identifiers *)
identifier = letter, { letter | digit | underscore } ;

(* Types *)
type = "int" | "float" | "string" | "bool" | "void" | "vector3" | "array" "[" type "]" | "map" "[" type "," type "]" | "option" "{" type "}" | identifier ;

(* Literals *)
integer_literal = digit, { digit } ;
float_literal = digit, { digit }, ".", digit, { digit } ;
string_literal = '"', { character }, '"' ;
boolean_literal = "true" | "false" ;

(* Operators and Expressions *)
expression = or_expression ;
or_expression = and_expression, { "or", and_expression } ;
and_expression = equality_expression, { "and", equality_expression } ;
equality_expression = relational_expression, { ( "=" | "<>" ), relational_expression } ;
relational_expression = additive_expression, { ( "<" | ">" | "<=" | ">=" ), additive_expression } ;
additive_expression = multiplicative_expression, { ( "+" | "-" ), multiplicative_expression } ;
multiplicative_expression = unary_expression, { ( "*" | "/" | "%" ), unary_expression } ;
unary_expression = [ ( "-" | "not" ) ], primary_expression ;
primary_expression = identifier | integer_literal | float_literal | string_literal | boolean_literal | "(", expression, ")" ;

(* Statements *)
statement = block | assignment | if_statement | while_statement | for_statement | return_statement | loop_statement | defer_statement | await_statement | expression_statement ;
block = "{", { statement }, "}" ;
assignment = identifier, ":=", expression, ";" ;
if_statement = "if", "(", expression, ")", statement, [ "else", statement ] ;
while_statement = "while", "(", expression, ")", statement ;
for_statement = "for", "(", [ assignment ], [ expression ], ";", [ assignment ], ")", statement ;
return_statement = "return", [ expression ], ";" ;
loop_statement = "loop", ":", block ;
defer_statement = "defer", ":", block ;
await_statement = "await", "(", expression, ")" ;
expression_statement = expression, ";" ;

(* Declarations *)
declaration = class_declaration | function_declaration | variable_declaration | module_declaration ;
module_declaration = "module", identifier, "{", { declaration }, "}" ;
class_declaration = "class", identifier, [ "(", identifier, ")" ], "{", { class_member }, "}" ;
class_member = variable_declaration | function_declaration ;
function_declaration = identifier, "(", [ parameter_list ], ")", [ "<", "computes" | "transacts" | "decides" | "suspends" | "converges" | "override" ,">" ], ":", type, "=", block ;
parameter_list = parameter, { ",", parameter } ;
parameter = identifier, ":", type ;
variable_declaration = "var", identifier, ":", type, [ ":=", expression ], ";" ;

(* Programs *)
program = { declaration } ;

(* Top-level rule *)
verse_program = { import_statement }, program ;
import_statement = "using", "{", string_literal, "}", ";" ;

Verse Quick Reference: https://dev.epicgames.com/documentation/en-us/uefn/verse-language-quick-reference
Verse more detail references:
Verse version updates: https://dev.epicgames.com/documentation/en-us/uefn/verse-language-version-updates-and-deprecations-in-verse
Verse expressions: https://dev.epicgames.com/documentation/en-us/uefn/expressions-in-verse
Verse comments: https://dev.epicgames.com/documentation/en-us/uefn/comments-in-verse
Verse constants and variables. Has global variables and persistable data: https://dev.epicgames.com/documentation/en-us/uefn/variables-in-verse
Verse common types: https://dev.epicgames.com/documentation/en-us/uefn/common-types-in-verse
> Logic: https://dev.epicgames.com/documentation/en-us/uefn/logic-in-verse
> Rational: https://dev.epicgames.com/documentation/en-us/uefn/rational-in-verse
> Int
Verse Operators: https://dev.epicgames.com/documentation/en-us/uefn/operators-in-verse
Verse Grouping: https://dev.epicgames.com/documentation/en-us/uefn/grouping-in-verse
Verse Basics: https://verse-book.netlify.app/verse/basics/

